// Safely import Workbox libraries with fallback
let workboxLoaded = false;

try {
  importScripts('https://storage.googleapis.com/workbox-cdn/releases/7.3.0/workbox-sw.js');
  workboxLoaded = typeof workbox !== 'undefined';
} catch (error) {
  console.log('Failed to load Workbox from CDN, falling back to basic service worker');
}

if (workboxLoaded && workbox) {
  console.log('Workbox loaded successfully');

  // Precache and route all assets generated by webpack
  workbox.precaching.precacheAndRoute(self.__WB_MANIFEST || []);

  // Cache CSS, JS, and Web Worker requests with a Stale While Revalidate strategy
  workbox.routing.registerRoute(
    // Check to see if the request's destination is style for stylesheets, script for JavaScript, or worker for web worker
    ({ request }) =>
      request.destination === 'style' ||
      request.destination === 'script' ||
      request.destination === 'worker',
    // Use a Stale While Revalidate caching strategy
    new workbox.strategies.StaleWhileRevalidate({
      // Put all cached files in a cache named 'assets'
      cacheName: 'assets',
      plugins: [
        // Ensure that once this runtime cache reaches a maximum size the least-recently used images are removed.
        new workbox.expiration.ExpirationPlugin({ maxEntries: 60 }),
      ],
    }),
  );

  // Cache images with a Cache First strategy
  workbox.routing.registerRoute(
    // Check to see if the request's destination is style for an image
    ({ request }) => request.destination === 'image',
    // Use a Cache First caching strategy
    new workbox.strategies.CacheFirst({
      // Put all cached files in a cache named 'images'
      cacheName: 'images',
      plugins: [
        // Ensure that once this runtime cache reaches a maximum size the least-recently used images are removed.
        new workbox.expiration.ExpirationPlugin({ maxEntries: 50 }),
      ],
    }),
  );

  // Cache API requests with a Network First strategy for better offline support
  workbox.routing.registerRoute(
    // Match API requests
    ({ url }) => url.pathname.startsWith('/api/'),
    // Use a Network First caching strategy
    new workbox.strategies.NetworkFirst({
      // Put all cached files in a cache named 'api'
      cacheName: 'api',
      plugins: [
        // Ensure that once this runtime cache reaches a maximum size the least-recently used entries are removed.
        new workbox.expiration.ExpirationPlugin({ maxEntries: 50 }),
      ],
    }),
  );

  // Implement background sync for form submissions
  const bgSyncPlugin = new workbox.backgroundSync.BackgroundSyncPlugin('apiRequests', {
    maxRetentionTime: 24 * 60 // Retry for up to 24 hours
  });

  // Register route for POST requests to API endpoints with background sync
  workbox.routing.registerRoute(
    ({ request }) => request.destination === 'empty' && request.method === 'POST' && request.url.includes('/api/'),
    new workbox.strategies.NetworkFirst({
      cacheName: 'api-post',
      plugins: [bgSyncPlugin],
    }),
    'POST'
  );

  // Catch routing errors, like if the user is offline
  // Register a navigation route that will be used when the user is offline
  const handler = workbox.precaching.createHandlerBoundToURL('/offline.html');
  const navigationRoute = new workbox.routing.NavigationRoute(handler, {
    // Allowlist all navigation requests
    allowlist: [
      // Match everything except paths starting with /api/
      ({ url }) => !url.pathname.startsWith('/api/'),
    ],
  });
  workbox.routing.registerRoute(navigationRoute);

  // Listen for push notifications
  self.addEventListener('push', (event) => {
    if (!(self.Notification && self.Notification.permission === 'granted')) {
      return;
    }
    
    const data = event.data ? event.data.json() : { title: 'Delta IMS', body: 'New notification' };
    
    const title = data.title;
    const options = {
      body: data.body,
      icon: '/logo192.png',
      badge: '/favicon.ico',
      data: data.url || '/',
      tag: 'delta-ims-notification',
      renotify: true
    };
    
    event.waitUntil(
      self.registration.showNotification(title, options)
    );
  });

  // Handle notification click
  self.addEventListener('notificationclick', (event) => {
    event.notification.close();
    
    event.waitUntil(
      clients.matchAll({ type: 'window' }).then((clientList) => {
        for (let i = 0; i < clientList.length; i++) {
          const client = clientList[i];
          if (client.url === '/' && 'focus' in client) {
            return client.focus();
          }
        }
        
        if (clients.openWindow) {
          return clients.openWindow(event.notification.data || '/');
        }
      })
    );
  });

  // Handle messages from client
  self.addEventListener('message', (event) => {
    if (event.data && event.data.type === 'SKIP_WAITING') {
      self.skipWaiting();
    }
  });
} else {
  console.log('Workbox not available, registering basic service worker');
  
  // Basic service worker functionality for offline support
  self.addEventListener('fetch', (event) => {
    // For now, we'll just let the browser handle requests normally
    // This avoids the error but doesn't provide offline functionality
    return;
  });
}